import { GITHUB_API_URL } from '../constants';
import { Discussion, GiscusConfig } from '../types';

const sanitizeInput = (text: string): string => {
    if (!text) return "";
    return text.trim();
};

/**
 * Creates a new discussion for the post if it doesn't exist.
 */
export const createDiscussion = async (config: GiscusConfig, token: string): Promise<Discussion | null> => {
  const mutation = `
    mutation($repositoryId: ID!, $categoryId: ID!, $title: String!, $body: String!) {
      createDiscussion(input: {repositoryId: $repositoryId, categoryId: $categoryId, title: $title, body: $body}) {
        discussion {
          id
          number
          url
        }
      }
    }
  `;

  // We use the 'term' as the title for automatic mapping
  const variables = {
    repositoryId: config.repoId,
    categoryId: config.categoryId,
    title: config.term,
    body: `Discussion for ${config.term}\n\nAuto-generated by Gist-Cus.`
  };

  const response = await fetch(GITHUB_API_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${sanitizeInput(token)}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ query: mutation, variables }),
  });

  const json = await response.json();
  if (json.errors) throw new Error(json.errors[0].message);
  
  // Return a partial discussion object (empty comments)
  const newDisc = json.data?.createDiscussion?.discussion;
  return newDisc ? { ...newDisc, comments: { totalCount: 0, nodes: [] } } : null;
};

/**
 * Fetches the discussion based on the search term.
 * Note: Giscus logic searches specifically within the repo and category.
 */
export const fetchDiscussion = async (config: GiscusConfig, token: string): Promise<Discussion | null> => {
  if (!config.repo || !config.term) return null;
  
  const [owner, name] = config.repo.split('/');
  const searchQuery = `repo:${owner}/${name} "${config.term}" in:title type:discussion`;

  const query = `
    query($searchQuery: String!) {
      search(query: $searchQuery, type: DISCUSSION, first: 1) {
        nodes {
          ... on Discussion {
            id
            number
            url
            comments(first: 50) {
              totalCount
              nodes {
                id
                createdAt
                body
                bodyHTML
                url
                author {
                  login
                  avatarUrl
                  url
                }
                reactionGroups {
                  content
                  users {
                    totalCount
                  }
                  viewerHasReacted
                }
                replies(first: 20) {
                  nodes {
                    id
                    createdAt
                    body
                    bodyHTML
                    url
                    author {
                      login
                      avatarUrl
                      url
                    }
                    reactionGroups {
                      content
                      users {
                        totalCount
                      }
                      viewerHasReacted
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;

  try {
    const response = await fetch(GITHUB_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${sanitizeInput(token)}`,
      },
      body: JSON.stringify({
        query,
        variables: { searchQuery },
      }),
    });

    const json = await response.json();
    if (json.errors) {
      console.error('GitHub API Errors:', json.errors);
      // Don't throw immediately on search fail, return null to prompt creation
      return null;
    }

    const nodes = json.data?.search?.nodes;
    return nodes && nodes.length > 0 ? nodes[0] : null;
  } catch (error) {
    console.error("Failed to fetch discussion", error);
    return null;
  }
};

export const fetchViewer = async (token: string) => {
  const query = `
    query {
      viewer {
        login
        avatarUrl
        url
      }
    }
  `;

  const response = await fetch(GITHUB_API_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${sanitizeInput(token)}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ query }),
  });

  const json = await response.json();
  return json.data?.viewer;
};

/**
 * Adds a TOP LEVEL comment to a discussion.
 */
export const addComment = async (discussionId: string, body: string, token: string) => {
  const cleanBody = sanitizeInput(body);
  if (!cleanBody) throw new Error("Comment body cannot be empty.");

  const mutation = `
    mutation($discussionId: ID!, $body: String!) {
      addDiscussionComment(input: {discussionId: $discussionId, body: $body}) {
        comment {
          id
        }
      }
    }
  `;

  const response = await fetch(GITHUB_API_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${sanitizeInput(token)}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      query: mutation,
      variables: { discussionId, body: cleanBody },
    }),
  });

  return response.json();
};

/**
 * Adds a REPLY to an existing comment.
 */
export const addReply = async (replyToId: string, body: string, token: string) => {
    const cleanBody = sanitizeInput(body);
    if (!cleanBody) throw new Error("Reply body cannot be empty.");
  
    const mutation = `
      mutation($replyToId: ID!, $body: String!) {
        addDiscussionReply(input: {replyToId: $replyToId, body: $body}) {
          reply {
            id
          }
        }
      }
    `;
  
    const response = await fetch(GITHUB_API_URL, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${sanitizeInput(token)}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        query: mutation,
        variables: { replyToId, body: cleanBody },
      }),
    });
  
    return response.json();
  };

export const toggleReaction = async (subjectId: string, content: string, token: string) => {
  const mutation = `
    mutation($subjectId: ID!, $content: ReactionContent!) {
      addReaction(input: {subjectId: $subjectId, content: $content}) {
        reaction {
          content
        }
      }
    }
  `;

  const response = await fetch(GITHUB_API_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${sanitizeInput(token)}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      query: mutation,
      variables: { subjectId, content },
    }),
  });

  return response.json();
};
